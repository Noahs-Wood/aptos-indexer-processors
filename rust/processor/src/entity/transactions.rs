//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.4

use crate::models::{
    default_models::{
        block_metadata_transactions::BlockMetadataTransactionModel, transactions::TransactionModel,
    },
    user_transactions_models::user_transactions::UserTransactionModel,
};
use aptos_protos::{
    transaction::v1::{
        transaction::TxnData, transaction_payload::Type, write_set::WriteSetType,
        Transaction as TransactionPB,
    },
    util::timestamp::Timestamp,
};
use rust_decimal::Decimal;
use sea_orm::{entity::prelude::*, ActiveValue::Set};
use std::str::FromStr;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[sea_orm(table_name = "transactions")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub transaction_version: String,
    pub transaction_block_height: i64,
    pub hash: String,
    pub transaction_type: String,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub payload: Option<Json>,
    pub payload_type: Option<String>,
    pub state_change_hash: String,
    pub event_root_hash: String,
    pub state_checkpoint_hash: Option<String>,
    pub gas_used: Decimal,
    pub success: bool,
    pub vm_status: String,
    pub accumulator_root_hash: String,
    pub num_events: i64,
    pub num_write_set_changes: i64,
    pub epoch: i64,
    pub parent_signature_type: Option<String>,
    pub sender: Option<String>,
    pub sequence_number: Option<i64>,
    pub max_gas_amount: Option<Decimal>,
    pub expiration_timestamp_secs: Option<DateTime>,
    pub gas_unit_price: Option<Decimal>,
    pub timestamp: Option<DateTime>,
    pub entry_function_id_str: Option<String>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub signature: Option<Json>,
    pub id: Option<String>,
    pub round: Option<i64>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub previous_block_votes_bitvec: Option<Json>,
    pub proposer: Option<String>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub failed_proposer_indices: Option<Json>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl ActiveModel {
    pub fn from_transactions(transactions: Vec<TransactionPB>) -> Vec<Self> {
        let mut transactions_to_return: Vec<ActiveModel> = vec![];
        for transaction in transactions {
            let (txn, blockmetadata_txn, _, _) = TransactionModel::from_transaction(&transaction);
            let txn_data = transaction
                .txn_data
                .as_ref()
                .expect("Txn Data doesn't exit!");
            let timestamp = &transaction.timestamp.as_ref().unwrap();
            transactions_to_return.push(Self::transaction_to_insert(
                transaction.clone(),
                txn,
                txn_data,
                blockmetadata_txn,
                timestamp,
            ));
        }
        transactions_to_return
    }

    fn transaction_to_insert(
        txn_pb: TransactionPB,
        txn: TransactionModel,
        txn_detail: &TxnData,
        blockmetadata_txn: Option<BlockMetadataTransactionModel>,
        timestamp: &Timestamp,
    ) -> Self {
        let mut transaction = Self {
            transaction_version: Set(txn.version.to_string()),
            transaction_block_height: Set(txn.block_height),
            hash: Set(txn.hash),
            transaction_type: Set(txn.type_),
            payload: Set(Some(serde_json::to_value(&txn.payload).unwrap())),
            state_change_hash: Set(txn.state_change_hash),
            event_root_hash: Set(txn.event_root_hash),
            state_checkpoint_hash: Set(txn.state_checkpoint_hash),
            success: Set(txn.success),
            vm_status: Set(txn.vm_status),
            accumulator_root_hash: Set(txn.accumulator_root_hash),
            gas_used: Set(Decimal::from_str(&txn.gas_used.to_string()).unwrap_or(Decimal::ZERO)),
            epoch: Set(txn.epoch),
            num_write_set_changes: Set(if let Some(info) = txn_pb.info {
                info.changes.len() as i64
            } else {
                0
            }),
            payload_type: Set(None),
            num_events: Set(0),
            parent_signature_type: Set(None),
            sender: Set(None),
            sequence_number: Set(None),
            max_gas_amount: Set(None),
            expiration_timestamp_secs: Set(None),
            gas_unit_price: Set(None),
            timestamp: Set(None),
            entry_function_id_str: Set(None),
            signature: Set(None),
            id: Set(None),
            round: Set(None),
            previous_block_votes_bitvec: Set(None),
            proposer: Set(None),
            failed_proposer_indices: Set(None),
        };

        match txn_detail {
            TxnData::User(inner) => {
                let (user_transaction, sigs) = UserTransactionModel::from_transaction(
                    inner,
                    timestamp,
                    txn.block_height,
                    txn.epoch,
                    txn.version,
                );
                transaction.parent_signature_type =
                    Set(Some(user_transaction.parent_signature_type));
                transaction.sender = Set(Some(user_transaction.sender));
                transaction.sequence_number = Set(Some(user_transaction.sequence_number));
                transaction.expiration_timestamp_secs =
                    Set(Some(user_transaction.expiration_timestamp_secs));
                transaction.timestamp = Set(Some(user_transaction.timestamp));
                transaction.entry_function_id_str =
                    Set(Some(user_transaction.entry_function_id_str));
                transaction.gas_unit_price = Set(Some(
                    Decimal::from_str(&user_transaction.gas_unit_price.to_string())
                        .unwrap_or(Decimal::ZERO),
                ));
                transaction.max_gas_amount = Set(Some(
                    Decimal::from_str(&user_transaction.max_gas_amount.to_string())
                        .unwrap_or(Decimal::ZERO),
                ));
                transaction.signature = Set(Some(serde_json::to_value(sigs).unwrap()));
                let payload = inner
                    .request
                    .as_ref()
                    .expect("Getting user request failed.")
                    .payload
                    .as_ref()
                    .expect("Getting payload failed.");
                transaction.payload_type = Set(Some(
                    Type::try_from(payload.r#type)
                        .expect("Payload type doesn't exist!")
                        .as_str_name()
                        .to_string(),
                ));
                transaction.num_events = Set(inner.events.len() as i64);
            },
            TxnData::BlockMetadata(inner) if blockmetadata_txn.is_some() => {
                let blockmetadata_txn = blockmetadata_txn.unwrap();
                transaction.id = Set(Some(blockmetadata_txn.id));
                transaction.round = Set(Some(blockmetadata_txn.round));
                let previous_block_votes_bitvec =
                    serde_json::to_string(&blockmetadata_txn.previous_block_votes_bitvec)
                        .unwrap_or_default();
                transaction.previous_block_votes_bitvec =
                    Set(Some(serde_json::Value::String(previous_block_votes_bitvec)));
                transaction.proposer = Set(Some(blockmetadata_txn.proposer));
                transaction.failed_proposer_indices =
                    Set(Some(blockmetadata_txn.failed_proposer_indices));
                transaction.num_events = Set(inner.events.len() as i64);
            },
            TxnData::Genesis(inner) => {
                let payload = inner.payload.as_ref().unwrap();
                transaction.payload_type = Set(Some(
                    WriteSetType::try_from(payload.write_set_type)
                        .expect("WriteSet type doesn't exist!")
                        .as_str_name()
                        .to_string(),
                ));
                transaction.num_events = Set(inner.events.len() as i64);
            },
            _ => {},
        }

        transaction
    }
}
